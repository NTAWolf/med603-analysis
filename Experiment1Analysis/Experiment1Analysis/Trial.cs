// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.IO;
using System.Collections.Generic;


namespace Experiment1Analysis
{
	public class Trial
	{
		/// <summary>
		/// The minimum number of seconds between observations.
		/// Used to determine what gaze-logged data belongs to which 
		/// stimulus and response.
		/// </summary>
		public const int MINIMUM_SECONDS_BETWEEN_OBSERVATIONS = 2;

		/// <summary>
		/// The set of observations that make up this Trial.
		/// </summary>
		/// <value>This Trial's observations.</value>
		public Observation[] observations
		{
			get;
			private set;
		}

		/// <summary>
		/// 1-based sequential ID of this trial in relation to the other
		/// trials done by its Participant
		/// </summary>
		/// <value>The ID</value>
		public int ID
		{
			get;
			private set;
		}

		/// <summary>
		/// The threshold as estimated by this trial, using the Best PEST algorithm.
		/// In other words, the last presented stimulus in this Trial.
		/// </summary>
		/// <value>The estimated threshold.</value>
		public float Threshold
		{
			get
			{
				return observations[observations.Length - 1].stimulus;
			}
		}

		private int _NumberOfReverses = -1;
		/// <summary>
		/// Gets the number of reverses in this trial, i.e. the number of times the user changed answer from positive to negative or vice versa.
		/// </summary>
		/// <value>The number of reverses.</value>
		public int NumberOfReverses
		{
			get
			{
				if(_NumberOfReverses < 0)
				{
					_NumberOfReverses = 0;
					for(int i = 1; i < observations.Length; i++)
					{
						if(observations[i].response != observations[i - 1].response && observations[i].response != 0)
						{
							_NumberOfReverses++;
						}
					}
				}
				return _NumberOfReverses;
			}
		}

		/// <summary>
		/// Initializes a new instance of the <see cref="Experiment1Analysis.Trial"/> class.
		/// </summary>
		/// <param name="observationLogStream">Observation log, as a stream.</param>
		/// <param name="gazeLogStream">Gaze log, as a stream.</param>
		/// <param name="ID">1-based sequential ID number</param>
		public Trial (StreamReader observationLogStream, StreamReader gazeLogStream, int ID, double clipObservationDurationMillis)
		{
			this.ID = ID;

			// Skip forward to point where we're past headers
			string[] observationsStrings = GetLinesStartingWithDigits(observationLogStream);
			string[] gazeStrings = GetLinesStartingWithDigits(gazeLogStream);			

			List<GazeLogEntry> gazeLogs = new List<GazeLogEntry>(gazeStrings.Length);
			List<int> observationsIndices = new List<int>(10);
			observationsIndices.Add (0);

			// Populate gazeLogs with data from gazeStrings, and find indices where a new observation begins
			for(int i = 0; i < gazeStrings.Length; i++)
			{
				gazeLogs.Add (new GazeLogEntry(gazeStrings[i]));
				if(i > 0)
				{
					TimeSpan ts = gazeLogs[i].timestamp - gazeLogs[i - 1].timestamp;
					if(ts.TotalSeconds >= MINIMUM_SECONDS_BETWEEN_OBSERVATIONS)
					{
						observationsIndices.Add (i);
					}
				}
			}

			observationsIndices.Add (gazeStrings.Length);
			observations = new Observation[observationsStrings.Length];

			// Generate Observations from the combined observation and gaze data
			// but disregard the last observation, as it is added by us
			for(int i = 0; i < observationsStrings.Length - 1; i++)
			{
				int fromIndex = observationsIndices[i];
				int toIndex = observationsIndices[i + 1];
				int gazeLogCount = toIndex - fromIndex;

				GazeLogEntry[] gazeEntriesForThisObservation = new GazeLogEntry[gazeLogCount];
				gazeLogs.CopyTo(fromIndex, gazeEntriesForThisObservation, 0, gazeLogCount);

				observations[i] = new Observation(
					observationsStrings[i],
					gazeEntriesForThisObservation,
					clipObservationDurationMillis);
			}

			observations[observations.Length - 1] = new Observation(
				observationsStrings[observations.Length - 1],
				new GazeLogEntry[]{},
				0);
		}

		// TODO doesn't work with negative numbers
		public static string[] GetLinesStartingWithDigits(StreamReader stream)
		{
			List<string> lines = new List<string>(10);

			while(false == stream.EndOfStream)
			{
				string line = stream.ReadLine();
				
				if(Char.IsDigit(line, 0))
				{
					lines.Add(line);
				}
			}

			return lines.ToArray();
		}

		public override string ToString ()
		{
			return string.Format ("Trial {0} with {2} reverses and threshold at {1}", ID, Threshold, NumberOfReverses);
		}

		public float GetMaximumSmoothedGazeDistance(int windowSize)
		{
			List<float> maxes = new List<float>(observations.Length);
			foreach(Observation o in observations)
			{
				maxes.Add(o.GetMaximumSmoothedGazeDistance(windowSize));
			}

			return Statistics.Max(maxes.ToArray());
		}

		public float GetMeanGazeDistance()
		{
			List<float> means = new List<float>(observations.Length);
			foreach(Observation o in observations)
			{
				means.Add(o.GazeDistanceMean);
			}

			return Statistics.Mean (means.ToArray());
		}

		public bool GazeOutsideBounds(int maxX, int maxY)
		{
			foreach(Observation o in observations)
			{
				if(o.GazeOutsideBounds(maxX, maxY))
				{
					return true;
				}
			}

			return false;
		}

		public int GetMaxNumberOfConsecutiveReadingsWithGazeDistanceAbove(float distance)
		{
			List<int> maxCounts = new List<int>(observations.Length);

			foreach(Observation o in observations)
			{
				maxCounts.Add(o.GetMaxNumberOfConsecutiveReadingsWithGazeDistanceAbove(distance));
			}

			return Statistics.Max(maxCounts.ToArray());
		}

		public List<float> ConcatenateStimuli()
		{
			List<float> output = new List<float>(observations.Length);

			foreach(Observation o in observations)
			{
				output.Add(o.stimulus);
			}

			return output;
		}

		public List<float> ConcatenateGazeDistances()
		{
			List<float> output = new List<float>(observations.Length);
			
			foreach(Observation o in observations)
			{
				output.AddRange(o.ConcatenateGazeDistances());
			}
			
			return output;
		}
	}
}

